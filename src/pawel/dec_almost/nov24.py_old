#import pysnooper


#@pysnooper.snoop()


def is_prime(number):  # Only up to 10^6
    return


def multiply(queue, current, visited, cost, A, B):
    if B > A:
        return cost, 0
    else:
        for X in range(2, B // current + 1):
            new_value = current * X
            if new_value == B:
                return cost + X, new_value
            if new_value < B and new_value not in visited:
                visited.add(new_value)
                queue.append((new_value, cost + X))
        return cost, 0  # ONLY AFTER EXHAUSTING for

def divide(queue, current, visited, cost, B):
    for Y in range(2, current + 1):  # divide
        if current % Y == 0:
            new_value = current // Y
            if new_value == B:
                return cost + Y, new_value
            if new_value > 0 and new_value not in visited:
                visited.add(new_value)
                queue.append((new_value, cost + Y))
    return cost, 0  # ONLY AFTER EXHAUSTING for


def min_bajtalars(A, B):  # 1, 20
    if A == B:
        return 0

    queue = [(A, 0)]
    visited = {A}

    while queue:  # BFS
        current, cost = queue.pop(0)

        cost1, new_value1 = multiply(queue, current, visited, cost, A, B)
        if new_value1 == B: # was 0
            return cost1
        cost2, new_value2 = divide(queue, current, visited, cost, B)

        # return cost2
        if new_value2 == B: # was above
            return cost2

    return -1


if __name__ == "__main__":
    # Reading the input
    A, B = map(int, input().split())

    # Print the minimum amount Bajtek has to pay
    print(min_bajtalars(A, B))
